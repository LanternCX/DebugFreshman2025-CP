# Debug 2025 Freshman - C Programing

## Chapter03 - Array, String and Function

### Array

回顾我们[第一次练习的 G 题](https://vjudge.net/contest/751860#problem/G)：这个问题要求我我们对输入的一组数据去掉最大值与最小值之后计算平均值。在生活中，我们也常常会碰到诸如此类的需要对多组、多个数据的处理，例如处理我们在高中学过的集合。

而在这个时候，直接通过我们上面所学的每个数据对应一个变量名进行存储的形式显然就不够好用了：既不能体现数据之间的分组关系又不能将数据集中起来统一处理。显然，我们需要一种更加合理的结构维护这些数据，而**数组（Array）**在这样的需求背景下应运而生。

**数组**，顾名思义，就是一组数字，可以理解为数学中的集合。在 C 语言中，我们这样表示数组：

```c++
// 定义了一个数组，能存放 100 个 int 类型的数组
int arr[100];
```

在这里我们定义了一个能存放 100 个 `int` 类型数据的数组，这里的 100 我们称为数组的**大小**或者**容量**，数组的大小是固定的，在数组初始化的时候就会被定义。

那么要如何使用数组呢？也很简单：

```c++
// 定义一个存放三个元素的数组
int arr[3];
// 将数组 arr 的前三个数分别赋值为 0, 1, 2
arr[0] = 0;
arr[1] = 1;
arr[2] = 2;
```

其中，方括号 `[ ]` 内的值被称为数组的**下标**，在 C 语言中，数组的下标**从 0 开始**，也就是说 `arr[0]` 是数组的第一个元素。

刚才我们已经学会了如何一个个地给数组元素赋值，但如果数组元素很多，一个一个写显然会非常麻烦。对于诸如此类的批量化操作，C 语言提供了一种不同于变量赋值的全新语法来帮助我们更好地操作数组，**初始化列表**：

```c++
// 定义并初始化一个包含 5 个整数的数组
int a[5] = {1, 2, 3, 4, 5};
```

在这行代码中，我们不仅定义了一个数组，还同时为它赋了初值。
 如果我们不给出数组大小，编译器会**自动根据初始化的数量**来推断数组长度：

```c++
// 编译器自动推断 b 的大小为 5
int b[] = {2, 4, 6, 8, 10};
```

另外，当数组在定义时使用初始化列表，但提供的初始值数量少于数组长度时，其余未指定的元素会自动初始化为 0，也就是说：

```c++
 // 所有元素都初始化为 0
int a[100] = {0};
```

可以通过这种方式将数组都初始化为 0

光有数据，但是不会处理当然是不行的。我们通常需要对这组数据做统一的处理，比如**求和、求最大值、最小值、平均值**等。

这时我们就需要**循环**来遍历数组的每一个元素：

```c++
int a[5] = {1, 2, 3, 4, 5};
int sum = 0;

for (int i = 0; i < 5; i++) {
    // 每次循环将第 i 个元素累加到 sum 中
    sum += a[i]; 
}

printf("sum = %d\n", sum);
```

在实际编程中，我们通常不会直接写死数组内容，而是**从输入中读取**：

```c++
int n;
// 读入数组长度
scanf("%d", &n);
// 定义一个最大长度为 100 的数组
int a[100];

for (int i = 0; i < n; i++) {
    // 依次输入数组元素
    scanf("%d", &a[i]); 
}

printf("input：\n");
for (int i = 0; i < n; i++) {
    printf("%d ", a[i]);
}
```

也就是在遍历的基础上进行输入。

需要注意的是，数组的**下标**，需要根据数组的定义使用，过大或者过小的下标都会导致**下标越界**，会出现一些意料之外的后果。

```c++
int a[3] = {1, 2, 3};
// 合法下标是 0, 1, 2
printf("%d", a[3]); 
```

和变量同样，未初始化数组就使用数组也是致命的：

```c++
int a[5];
// 未赋值的数组元素是“随机值”
printf("%d", a[0]); 
```

在生活中，很多数据并不是单一维度的，而是表格形式的：

| 姓名 | 语文 | 数学 | 英语 |
| ---- | ---- | ---- | ---- |
| 张三 | 90   | 85   | 88   |
| 李四 | 78   | 92   | 81   |
| 王五 | 84   | 76   | 90   |

这个时候，使用只有一个下标的数组 $ a_i $ 表示就不太合适，C 语言中，这样的数据就天然地适合用**二维数组**表示。

二维数组本质上就是**数组的数组**，类比数学中集合的集合。
 它可以看成是一张**表格**：有**行（row）**和**列（column）**。

```c++
int a[3][4];
```

这行代码定义了一个 **3 行 4 列** 的整数数组，总共有 `3 × 4 = 12` 个元素。

- `a[0][0]` 表示第一行第一列；
- `a[2][3]` 表示第三行第四列；
- 行下标、列下标都从 **0 开始**。

二维数组也可以像一维数组那样用花括号初始化：

```c++
int a[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
```

二维数组最常见的使用方式是**双重循环**：

```c++
int a[2][3] = {{1, 2, 3}, {4, 5, 6}};
// 外层循环遍历行
for (int i = 0; i < 2; i++) {
    // 内层循环遍历列
    for (int j = 0; j < 3; j++) {
        printf("(%d, %d) = %d ", i, j, a[i][j]);
    }
    printf("\n");
}
```

虽然我们用行和列来理解二维数组，但在计算机内存中，它仍然是**连续存储**的。

例如：

```c++
int a[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
```

在内存中其实是这样的：

| 内存顺序 | 元素值 | 下标    |
| -------- | ---- | ------- |
| 第1个    | 1    | (0, 0) |
| 第2个    | 2    | (0, 1) |
| 第3个    | 3    | (0, 2) |
| 第4个    | 4    | (1, 0) |
| 第5个    | 5    | (1, 1) |
| 第6个    | 6    | (1, 2) |

也就是说，**按行连续存储（Row-major order）**。因此根据数据的存储规则，先遍历行再遍历列的写法比先遍历列再遍历行的写法访问数据要快的多。

同样的，我们也有更多的高维数组。

### 字符串

数组和普通变量一样有着不同的类型，而 `char` 型数组则最为特殊。

在生活中，我们经常需要处理文字数据，比如：

> “Hello, World!”
>  “I love C language.”

这些由**字符（char）**组成的一串文本，就是**字符串（String）**。

在 C 语言中，我们定义一个以字符 `\0` （空字符）结尾的字符型数组为一个字符串 (String)： 

```c++
char str[] = {'H', 'e', 'l', 'l', 'o', '\0'};
```

注意最后的 `\0` ，它不是数字 0，也不是字符 `'0'`，而是一个特殊的结束标志，告诉程序：字符串到这里就结束了。

C 语言为我们提供了一种更方便的写法来定义字符串：

```c++
// 自动在末尾加上 '\0'
char str1[] = "Hello";
// 剩下的元素会自动补 '\0'
char str2[10] = "Hi";
```

这两种写法是等价的：

```c++
char str1[] = {'H', 'e', 'l', 'l', 'o', '\0'};
```

C 语言标准库提供了两种常用的字符串输入方式：

```c++
char name[20];
// 注意这里不需要写 `&`，尽管可以写
// 读取时会在遇到空格、换行或制表符时停止
scanf("%s", name);
printf("Hello, %s!\n", name);
```

**input**：

```
Alice
```

**output**：

```
Hello, Alice!
```

或者使用 `gets()` 或者 `fgets()`：

```c++
char line[100];
// 从标准输入读取一整行
fgets(line, sizeof(line), stdin);
printf("input：%s", line);
```

`gets()` 与 `fgets()` 等价，但是 `fgets()` 更为安全。

使用字符串也非常容易，因为字符串其实就是一个字符数组，因此可以像数组一样访问：

```c++
char str[] = "Hello";
// 字符串的结尾是 '\0' 因此可以通过这个特征判断字符串的终点
for (int i = 0; str[i] != '\0'; i++) {
    printf("%c ", str[i]);
}
```

就可以得到：

```
H e l l o
```

C 标准库中提供了许多处理字符串的函数，它们都在 `<string.h>` 头文件里。

| 函数                | 功能                        | 示例                       |
| ------------------- | --------------------------- | -------------------------- |
| `strlen(s)`         | 计算字符串长度（不含 `\0`） | `strlen("abc") → 3`        |
| `strcpy(dest, src)` | 把 `src` 拷贝到 `dest`      | `strcpy(a, "hello")`       |
| `strcat(dest, src)` | 把 `src` 拼接到 `dest` 后面 | `strcat(a, "world")`       |
| `strcmp(a, b)`      | 比较字符串大小（按字典序）  | `strcmp("abc", "abd") < 0` |

更多详细内容可以看：[string.h | 菜鸟教程](https://www.runoob.com/cprogramming/c-standard-library-string-h.html)

需要注意的是，在 C 语言中，使用单引号 `' '` 表示字符，而双引号表示字符串 `" "`，也就是说，`'A'` 表示字符常量，`"A"` 表示字符串常量。

数字可以比较，那么字符串可以比较吗？当然是可以的。我们定义字符串的大小顺序为**字典序**，也就是按照字典内单词的排列顺序排序：

字典序的规则非常简单：

从第一个字符开始，一个一个地比较，直到找到第一个不同的字符，谁的那个字符“更小”，谁就更靠前。

例如

| 比较对象                | 结果           |
| ----------------------- | -------------- |
| `"apple"` vs `"banana"` | `"apple"` 更小 |
| `"hello"` vs `"hi"`     | `"hello"` 更小 |
| `"abc"` vs `"abcd"`     | `"abc"` 更小   |

这个比较可以通过上面提到的 `strcmp(a, b)` 完成。
